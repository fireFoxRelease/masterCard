/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
PURPOSE.

Module Name:

IsrDpc.c

Abstract:

Contains routines related to interrupt and dpc handling.

Environment:

Kernel mode

--*/


#include "driver.h"
#include "IsrDpc.tmh"
//#include "ntddk.h"
//#pragma pack(push, 8)
//unsigned long timeMs1;
#if 1

NTSTATUS
MasterCardInterruptCreate(
IN PDEVICE_CONTEXT DevExt
)
/*++
Routine Description:

	Configure and create the WDFINTERRUPT object.
	This routine is called by EvtDeviceAdd callback.

Arguments:

	DevExt      Pointer to our DEVICE_EXTENSION

Return Value:

	NTSTATUS code

--*/
{
	NTSTATUS                    status;
	WDF_INTERRUPT_CONFIG        InterruptConfig;

	//注册中断处理函数
	WDF_INTERRUPT_CONFIG_INIT(&InterruptConfig,
		MasterCardEvtInterruptIsr,
		MasterCardEvtInterruptDpc);

	InterruptConfig.EvtInterruptEnable = MasterCardEvtInterruptEnable; //中断使能
	InterruptConfig.EvtInterruptDisable = MasterCardEvtInterruptDisable; //中断禁止

	// JOHNR: Enable testing of the DpcForIsr Synchronization
	InterruptConfig.AutomaticSerialization = TRUE;

	//
	// Unlike WDM, framework driver should create interrupt object in EvtDeviceAdd and
	// let the framework do the resource parsing and registration of ISR with the kernel.
	// Framework connects the interrupt after invoking the EvtDeviceD0Entry callback
	// and disconnect before invoking EvtDeviceD0Exit. EvtInterruptEnable is called after
	// the interrupt interrupt is connected and EvtInterruptDisable before the interrupt is
	// disconnected.
	//

	//创建中断对象
	status = WdfInterruptCreate(DevExt->Device,
		&InterruptConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		&DevExt->Interrupt);

	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"WdfInterruptCreate failed: %!STATUS!", status);
	}
	status = 0;
	return status;
}

int intCount;
BOOLEAN
MasterCardEvtInterruptIsr(
IN WDFINTERRUPT Interrupt,
IN ULONG        MessageID
)
/*++
Routine Description:

	Interrupt handler for this driver. Called at DIRQL level when the
	device or another device sharing the same interrupt line asserts
	the interrupt. The driver first checks the device to make sure whether
	this interrupt is generated by its device and if so clear the interrupt
	register to disable further generation of interrupts and queue a
	DPC to do other I/O work related to interrupt - such as reading
	the device memory, starting a DMA transaction, coping it to
	the request buffer and completing the request, etc.

Arguments:

	Interupt   - Handle to WDFINTERRUPT Object for this device.
	MessageID  - MSI message ID (always 0 in this configuration)

Return Value:

	TRUE   --  This device generated the interrupt.
	FALSE  --  This device did not generated this interrupt.

--*/
{
	PDEVICE_CONTEXT   devExt;
	BOOLEAN           isRecognized3609 = FALSE;
	unsigned int	  tmpIntCount = 0;

	//LARGE_INTEGER  locateTime, currentTime;
	//TIME_FIELDS system_time;

	UNREFERENCED_PARAMETER(MessageID);
	//KdPrint((_DRIVER_NAME_":--------MasterCardEvtInterruptIsr\n"));
	devExt = DeviceGetContext(WdfInterruptGetDevice(Interrupt)); //返回框架中断对象句柄
	//intCount++;

	//change 2021 11 09
	//unsigned int* pBar0Addr = (unsigned int*)((unsigned long long)devExt->Bar0VirtualAddress + 0xE00208);//for int clear
	//unsigned int* pBar0Addr2 = (unsigned int*)((unsigned long long)devExt->Bar0VirtualAddress + 0xE0020C);//for int count
	//confim the interrupt is right 
	//tmpIntCount = *pBar0Addr2;
	//if (devExt->intCount == tmpIntCount)
	//{
	//	return isRecognized3609;
	//}
	devExt->intCount++;

	//clear int
	//*pBar0Addr = 1;
	//KdPrint((_DRIVER_NAME_":--------MasterCardEvtInterruptIsr intcount:%d \n", devExt->intCount));


	//intCsr.ulong = READ_REGISTER_ULONG((PULONG)&devExt->Regs->Int_Csr);  //插入内存屏障？？？ 入口参数为一个映射范围内的指针


	//KIRQL curkirql = 0;
	//curkirql = KeGetCurrentIrql(); //获取当前IRQL
	//KdPrint((_DRIVER_NAME_"KeGetCurrentIrql irq %d\n", curkirql));

	//
	// Read the Interrupt CSR register (INTCSR)
	//

	//KdPrint((_DRIVER_NAME_":INTCSR:%x \n", intCsr.ulong));
	//
	// Is DMA channel 0 (Write-side) Active?
	//
#if 1
	
	char *intStatue = (char *)devExt->Bar0VirtualAddress;
	intStatue += 0x34;
	//KdPrint((_DRIVER_NAME_":geInterruptType=%p  data=%x \n", intStatue, *intStatue));
	
	//unsigned int* dmacount = (unsigned int * )devExt->RxDMABuffer;
	//dmacount = dmacount + 1;
	

	
	//printf("---packetCount = %d \n", packetCount);
	/*LARGE_INTEGER nFreq, nFreq1;
	long long counterValue, timeUs, timeMs,  timeMs2;
	unsigned long timeIncrement, frequency;
	
	LARGE_INTEGER litmp;*/
	if (*intStatue == 1) 
	{

		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,      //打印日志用
			" Interrupt for DMA Channel 0 (write)");
		
		//KdPrint((_DRIVER_NAME_":geInterruptType=%p  data=%x \n", intStatue, *intStatue));
		//devExt->IntCsr.bits.DmaChan0IntActive = TRUE;

		////
		//// Clear this interrupt.
		////
		//devExt->Dma0Csr.uchar =
		//	READ_REGISTER_UCHAR((PUCHAR)&devExt->Regs->Dma0_Csr);

		//devExt->Dma0Csr.bits.Clear = TRUE;
	

		//int tmp = 0;
		//tmp = devExt->ReadCommonBuffer->unused;
		//KeQuerySystemTime(&currentTime);//获取GMT系统时间
		//RtlTimeToTimeFields(&currentTime, &system_time);
		
		/*PVOID ReadCommonBufferBase = WdfCommonBufferGetAlignedVirtualAddress(devExt->ReadCommonBuffer);
		unsigned int* tmpCount = (unsigned int *)ReadCommonBufferBase;
		unsigned char* chn = (unsigned char*)ReadCommonBufferBase;
		unsigned int* completeCount = (unsigned int*)ReadCommonBufferBase;*/
		//KdPrint((_DRIVER_NAME_":---11system_time:%lld   Time :%02d-%02d-%02d  %02d:%02d:%02d:%03d  dmaCount = %d  chn = %d  completeCount = %d\n", currentTime.QuadPart, system_time.Year, system_time.Month, system_time.Day, system_time.Hour, system_time.Minute, system_time.Second, system_time.Milliseconds, *(tmpCount+1),(*(chn+3))>>4, *(completeCount+2)));
		


		isRecognized3609 = TRUE;
		WRITE_REGISTER_UCHAR((PUCHAR*)intStatue, 0x1);
	}


	
#endif
	//add wzx 2021 11 09
	if (isRecognized3609) {
		//
		// A read or a write or both is done. Queue a DPC.
		//
		//KdPrint((_DRIVER_NAME_":isr->dpc \n"));
		WdfInterruptQueueDpcForIsr(devExt->Interrupt);
	}
	//WdfInterruptQueueDpcForIsr(devExt->Interrupt);   //EvtInterruptDpc的回调函数排队
	isRecognized3609 = FALSE;

	//TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INTERRUPT,
	//            "<-- PLxInterruptHandler");

	return isRecognized3609;
}

//void intThread(IN void* pContext)
//{
//	PDEVICE_CONTEXT pDevContext;
//	NTSTATUS ntStatus = STATUS_SUCCESS;
//
//	KdPrint((_DRIVER_NAME_"intThread in "));
//	pDevContext = (PDEVICE_CONTEXT)pContext;
//
//	KIRQL curkirql = 0;
//	curkirql = KeGetCurrentIrql(); //获取当前IRQL
//	KdPrint((_DRIVER_NAME_"KeGetCurrentIrql irq %d\n", curkirql));
//
//	if (pDevContext->pEvent)
//	{
//		KdPrint((_DRIVER_NAME_":set event\n"));
//		//KeSetEvent(pDevContext->pEvent, IO_NO_INCREMENT, FALSE);
//	}
//}

_Use_decl_annotations_
VOID
MasterCardEvtInterruptDpc(
WDFINTERRUPT Interrupt,
WDFOBJECT    Device
)
/*++

Routine Description:

	DPC callback for ISR. Please note that on a multiprocessor system,
	you could have more than one DPCs running simulataneously on
	multiple processors. So if you are accesing any global resources
	make sure to synchrnonize the accesses with a spinlock.

Arguments:

	Interupt  - Handle to WDFINTERRUPT Object for this device.
	Device    - WDFDEVICE object passed to InterruptCreate

Return Value:

--*/
{
	NTSTATUS            status;
	WDFDMATRANSACTION   dmaTransaction;
	PDEVICE_CONTEXT		devExt;
	BOOLEAN             writeInterrupt = FALSE;
	BOOLEAN             readInterrupt = FALSE;

	UNREFERENCED_PARAMETER(Device);

	//LARGE_INTEGER  locateTime, currentTime;
	//TIME_FIELDS system_time;

	//KdPrint((_DRIVER_NAME_":MasterCardEvtInterruptDpc\n"));
	//TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> EvtInterruptDpc");

	devExt = DeviceGetContext(WdfInterruptGetDevice(Interrupt));

	//
	// Acquire this device's InterruptSpinLock.
	//

	//change 2021 11 09
	//WdfInterruptAcquireLock(Interrupt);

#if 0
	if ((devExt->IntCsr.bits.DmaChan0IntActive) &&
		(devExt->Dma0Csr.bits.Done)) {

		//
		// If Dma0 channel 0 (write) is interrupting and the
		//  Done bit is set in the Dma0 CSR,
		//  we're interrupting because a WRITE is complete.
		// Clear the done bit and channel interrupting bit from
		//  our copies...
		//
		devExt->IntCsr.bits.DmaChan0IntActive = FALSE;
		devExt->Dma0Csr.uchar = 0;

		writeInterrupt = TRUE;
	}

	if ((devExt->IntCsr.bits.DmaChan1IntActive) &&
		(devExt->Dma1Csr.bits.Done)) {

		//
		// If DMA channel 1 is interrupting and the
		//  DONE bit is set in the DMA1 control/status
		//  register, we're interrupting because a READ
		//  is complete.
		// Clear the done bit and channel interrupting bit from
		//  our copies...
		//
		devExt->IntCsr.bits.DmaChan1IntActive = FALSE;
		devExt->Dma0Csr.uchar = 0;

		readInterrupt = TRUE;
	}
#endif

	KIRQL curkirql = 0;
	curkirql = KeGetCurrentIrql(); //获取当前IRQL
	//KdPrint((_DRIVER_NAME_"KeGetCurrentIrql irq %d\n", curkirql));



	//change 2021 11 09
	if (curkirql <= DISPATCH_LEVEL)
	{
		if (devExt->pEvent)
		{
			//KdPrint((_DRIVER_NAME_":set event\n"));
			KeSetEvent(devExt->pEvent, IO_NO_INCREMENT, FALSE);   //增加irql等级

			//KeQuerySystemTime(&currentTime);//获取GMT系统时间
			//RtlTimeToTimeFields(&currentTime, &system_time);
			//KdPrint((_DRIVER_NAME_":---KeSetEvent_time:%lld   Time :%02d-%02d-%02d  %02d:%02d:%02d:%03d \n", currentTime.QuadPart, system_time.Year, system_time.Month, system_time.Day, system_time.Hour, system_time.Minute, system_time.Second, system_time.Milliseconds));

		}
	}
	/*HANDLE hIntThread;

	PsCreateSystemThread(&hIntThread, 0, NULL, NtCurrentProcess(), NULL, intThread, devExt);*/

	//
	// Release our interrupt spinlock
	//
	//change 2021 11 09
	//WdfInterruptReleaseLock(Interrupt);   //释放锁，恢复irql等级

#if 0
	//
	// Did a Write DMA complete?
	//
	if (writeInterrupt) {

		BOOLEAN transactionComplete;

		//
		// Get the current Write DmaTransaction.
		//
		dmaTransaction = devExt->WriteDmaTransaction;

		//
		// Indicate this DMA operation has completed:
		// This may drive the transfer on the next packet if
		// there is still data to be transfered in the request.
		//
		transactionComplete = WdfDmaTransactionDmaCompleted(dmaTransaction,
			&status);

		if (transactionComplete) {
			//
			// Complete this DmaTransaction.
			//
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"Completing Write request in the DpcForIsr");

			PLxWriteRequestComplete(dmaTransaction, status);

		}
	}

	//
	// Did a Read DMA complete?
	//
	if (readInterrupt) {

		BOOLEAN                transactionComplete;
		PDMA_TRANSFER_ELEMENT  dteVA;
		size_t                 length;

		//
		// Get the current Read DmaTransaction.
		//
		dmaTransaction = devExt->ReadDmaTransaction;

		//
		// Only on Read-side --
		//    Use "DMA Clear-Count Mode" to get complemetary
		//    transferred byte count.
		//
		length = WdfDmaTransactionGetCurrentDmaTransferLength(dmaTransaction);

		dteVA = (PDMA_TRANSFER_ELEMENT)devExt->ReadCommonBufferBase;

		while (dteVA->DescPtr.LastElement == FALSE) {
			length -= dteVA->TransferSize;
			dteVA++;
		}
		length -= dteVA->TransferSize;

		//
		// Indicate this DMA operation has completed:
		// This may drive the transfer on the next packet if
		// there is still data to be transfered in the request.
		//
		transactionComplete =
			WdfDmaTransactionDmaCompletedWithLength(dmaTransaction,
			length,
			&status);

		if (transactionComplete) {
			//
			// Complete this DmaTransaction.
			//
			TraceEvents(TRACE_LEVEL_INFORMATION, DBG_DPC,
				"Completing Read request in the DpcForIsr");

			PLxReadRequestComplete(dmaTransaction, status);

		}
	}
#endif
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- EvtInterruptDpc");

	return;
}

NTSTATUS
MasterCardEvtInterruptEnable(
IN WDFINTERRUPT Interrupt,
IN WDFDEVICE    Device
)
/*++

Routine Description:

	Called by the framework at DIRQL immediately after registering the ISR with the kernel
	by calling IoConnectInterrupt.

Return Value:

	NTSTATUS
--*/
{
	PDEVICE_CONTEXT  devExt;



	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
		"PLxEvtInterruptEnable: Interrupt 0x%p, Device 0x%p\n",
		Interrupt, Device);

	devExt = DeviceGetContext(WdfInterruptGetDevice(Interrupt));
	return STATUS_SUCCESS;
}

NTSTATUS
MasterCardEvtInterruptDisable(
IN WDFINTERRUPT Interrupt,
IN WDFDEVICE    Device
)
/*++

Routine Description:

	Called by the framework at DIRQL before Deregistering the ISR with the kernel
	by calling IoDisconnectInterrupt.

Return Value:

	NTSTATUS
--*/
{
	PDEVICE_CONTEXT  devExt;


	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
		"PLxEvtInterruptDisable: Interrupt 0x%p, Device 0x%p\n",
		Interrupt, Device);

	devExt = DeviceGetContext(WdfInterruptGetDevice(Interrupt));
	return STATUS_SUCCESS;
}

#endif